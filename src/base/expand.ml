(* Types and helpers for macro expansion. *)

module Utils = struct
    let macro_op_to_mic (op : Mic.Macro.op) : Mic.t =
        let leaf : Mic.leaf =
            match op with
            | Mic.Macro.Eq -> Eq
            | Mic.Macro.Neq -> Neq
            | Mic.Macro.Lt -> Lt
            | Mic.Macro.Le -> Le
            | Mic.Macro.Ge -> Ge
            | Mic.Macro.Gt -> Gt
        in
        Mic.mk (Mic.Leaf leaf)
end

let macro_cmp (op : Mic.Macro.op) : Mic.t list = [
    Mic.mk_leaf Mic.Compare ;
    Utils.macro_op_to_mic op ;
]
let macro_if (op : Mic.Macro.op) (i_1 : Mic.t) (i_2 : Mic.t) : Mic.t list = [
    Utils.macro_op_to_mic op ;
    Mic.If (i_1, i_2) |> Mic.mk ;
]
let macro_if_cmp (op : Mic.Macro.op) (i_1 : Mic.t) (i_2 : Mic.t) : Mic.t list = [
    Mic.mk_leaf Mic.Compare ;
    Utils.macro_op_to_mic op ;
    Mic.If (i_1, i_2) |> Mic.mk ;
]

let macro_fail : Mic.t list = [
    Mic.mk_leaf Mic.Unit ;
    Mic.mk_leaf Mic.Failwith ;
]

let macro_assert : Mic.t list = [
    Mic.If (Mic.mk_seq [],  Mic.mk_seq macro_fail) |> Mic.mk ;
]

let macro_assert_ (op : Mic.Macro.op) : Mic.t list =
    macro_if op (Mic.mk_seq []) (Mic.mk_seq macro_fail)

let macro_assert_cmp (op : Mic.Macro.op) : Mic.t list =
    macro_if_cmp op (Mic.mk_seq []) (Mic.mk_seq macro_fail)

let macro_assert_none : Mic.t list = [
    Mic.IfNone (Mic.mk_seq [], Mic.mk_seq macro_fail) |> Mic.mk ;
]

let macro_assert_some : Mic.t list = [
    Mic.IfNone (Mic.mk_seq macro_fail, Mic.mk_seq []) |> Mic.mk ;
]

let macro_assert_left : Mic.t list = [
    Mic.IfLeft (Mic.mk_seq [], Mic.mk_seq macro_fail) |> Mic.mk ;
]

let macro_assert_right : Mic.t list = [
    Mic.IfLeft (Mic.mk_seq macro_fail, Mic.mk_seq []) |> Mic.mk ;
]

let macro_dip (n : int) (code : Mic.t) : Mic.t list =
    assert (n > 0);
    (* Note that `DIIP <code>` expands to `DIP (DIP <code>)`.
        Hence we're generating `n + 1` nested `DIP`s.
    *)
    let rec loop (acc : Mic.t) (count : int) : Mic.t =
        if count > 0 then loop (Mic.Dip acc |> Mic.mk) (count - 1)
        else acc
    in
    [ loop (Mic.Dip code |> Mic.mk) n ]

let macro_dup (annot : Annot.vars) (n : int) : Mic.t list =
    assert (n > 0);
    (* Note that `DUUP <code>` expands to `DIP (DUP <code>)`.
        Hence we're generating `n + 1` nested `DIP`s.
    *)
    let rec loop (acc : Mic.t) (count : int) : Mic.t =
        if count > 0 then loop (Mic.Dip acc |> Mic.mk) (count - 1)
        else acc
    in
    [ loop (Mic.Dup |> Mic.mk_leaf ~vars:annot) n ]

(* The following deals with pairs...

    The way this is done is by constructing an intermediary tree. This step can be removed but
    for now that's how it works.
    
    The types/helpers below are for tree construction. `pre_tree` is the type of the frames of
    the stack maintained. A frame corresponds to a pair constructor. When tree building goes
    up, meaning a tree was constructed, it looks at the top of the stack and checks whether i)
    we're done, ii) we just built the left part of a pair (and need to do the right one), or
    iii) we just built the right part of a pair and need to combine it with its left part.
*)
module PairHelp = struct
    (* Bail for pair macro expansion. *)
    let bail_pair () : 'a =
        Exc.throw "illegal sequence of characters"

    (* Intermediary structure generated by the function below. *)
    type tree =
    | LeafI
    | LeafA
    | Pair of tree * tree

    (* Stack frame: when building the tree and going up, this tells us what to do.

        Values of this type are added to the stack when reading a pair `P` constructor.
    *)
    type pre_tree =
    (* Initial stack frame pushed when running in a pair constructor. When going up, it means "keep
        reading for the right part of the pair".
    *)
    | PairLeft
    (* When going up the variant above, we need to remember the tre constructed for the left branch
        of the pair. This variant stores it.

        When going up, it means "keep going up by combining this tree and the tree you just
        constructed".
    *)
    | PairRight of tree

    (* Tree formatter, for debugging. Not tailrec. *)
    (* let rec fmt_tree (fmt : formatter) (tree : tree) =
        match tree with
        | LeafI -> fprintf fmt "I"
        | LeafA -> fprintf fmt "A"
        | Pair (lft, rgt) -> fprintf fmt "P(%a,%a)" fmt_tree lft fmt_tree rgt *)

    (* Turns a sequence of pair operators into a tree.

        This is used to expand `P[AIP]+R` and `UNP[AIP]+R` macros.
    *)
    let macro_pair_to_tree (ops : Mic.Macro.pair_op list) : tree =

        (* Look at the stream of pair operators and decide what to do. *)
        let rec go_down
            (stack : pre_tree list)
            (to_do : Mic.Macro.pair_op list)
            : tree
        =
            (* log_1 "down (%i)@." (List.length to_do); *)
            match to_do with

            (* Going up from the left branch. *)
            | A :: to_do ->
                (* log_1 "  A@."; *)
                go_up stack to_do LeafA

            (* Going up from the right branch. *)
            | I :: to_do ->
                (* log_1 "  I@."; *)
                go_up stack to_do LeafI

            (* Go down the left part of a pair constructor. *)
            | P :: to_do ->
                (* log_1 "  P@."; *)
                go_down (PairLeft :: stack) to_do

            | [] -> bail_pair ()

        (* Given a tree, check the stack and decide to go up or down. *)
        and go_up
            (stack : pre_tree list)
            (to_do : Mic.Macro.pair_op list)
            (tree : tree)
            : tree
        =
            (* log_1 "up %a@." fmt_tree tree; *)
            match stack with

            (* Going up a left branch, need to go down the left branch now. *)
            | PairLeft :: stack ->
                (* log_1 "  P left@."; *)
                go_down ((PairRight tree) :: stack) to_do

            (* Going up a right branch from a pair constructor. *)
            | (PairRight left_branch) :: stack -> 
                (* log_1 "  P right@."; *)
                go_up stack to_do (Pair (left_branch, tree))

            (* Reached the top of the stack, there should be no operator left. *)
            | [] -> if to_do = [] then tree else bail_pair ()
        in

        ops |> go_down []

    (* This type encodes the type of stack frames when expanding the tree.

        The process builds a list of instructions, and this types says what to do with it.

        Each variant corresponds to one of the `A`, `I` and `P` pair operators. The last two
        variants deal with `P`.
    *)
    type stack_frame =
    (* Going up an `A`: `DIP` the instructions and add `PAIR` at the end. *)
    | UppDipPost
    (* Going up an `I`: add `PAIR` at the beginning. *)
    | UppPref
    (* Going up a partial `P`: current instructions describe the left part. This tree is the right
        part. We need to go down this tree and remember the left part using the `Upp` variant
        below.
    *)
    | Dwn of tree
    (* Going up a `P` for which we have the left part. Current instructions are the right part.
        Done, concatenate and add `PAIR` at the end. *)
    | Upp of Mic.t list

    (* Turns a tree for a pair macro into a list of instructions. *)
    let macro_pair_tree_to_list (tree : tree) : Mic.t list =
        (* Go down the tree and decide what to do. *)
        let rec go_down (stack : stack_frame list) (tree : tree) : Mic.t list =
            match tree with
            (* Simple pair constructor. *)
            | Pair (LeafA, LeafI) -> go_up stack [Mic.mk_leaf Mic.Pair]
            (* Left part is fine, go down the left part. *)
            | Pair (LeafA, right) -> go_down (UppDipPost :: stack) right
            (* Right part is fine, go down the right part. *)
            | Pair (left, LeafI) -> go_down (UppPref :: stack) left
            (* Go down left first, then right. *)
            | Pair (left, right) -> go_down (
                (Dwn right) :: stack
            ) left
            (* Everything else should be illegal. *)
            | _ -> bail_pair ()
        (* Go up the stack, building the instructions as we go. *)
        and go_up (stack : stack_frame list) (lst : Mic.t list) : Mic.t list =
            match stack with
            (* Going up an `A`: `DIP` instructions and add `PAIR` at the end. *)
            | UppDipPost :: stack ->
                let dipped = Mic.Dip (Mic.mk_seq lst) |> Mic.mk in
                go_up stack [dipped ; Mic.mk_leaf Mic.Pair]
            (* Going up an `I`: prefix with `PAIR`. *)
            | UppPref :: stack ->
                go_up stack ((Mic.mk_leaf Mic.Pair) :: lst)
            (* Need to go down `tree`, memorize `lst` in the stack for later. *)
            | (Dwn tree) :: stack ->
                go_down ((Upp lst) :: stack) tree
            (* We have the left (`pref`) and right (`lst`) instructions, just need to build the
                pair.
            *)
            | (Upp pref) :: stack ->
                go_up stack (pref @ lst @ [Mic.mk_leaf Mic.Pair])
            (* We drained the stack, done. *)
            | [] -> lst
        in
        go_down [] tree

    (* This type encodes the type of stack frames when expanding the tree.

        The process builds a list of instructions, and this types says what to do with it.

        Each variant corresponds to one of the `A`, `I` and `P` pair operators. The last two
        variants deal with `P`.
    *)
    type un_stack_frame =
    (* Going up an `A`: `DIP` the instructions and add `UNPAIR` at the beginning. *)
    | UppDipPref
    (* Going up an `I`: add `PAIR` at the beginning. *)
    | UppPref
    (* Going up a partial `P`: current instructions describe the left part. This tree is the right
        part. We need to go down this tree and remember the left part using the `Upp` variant
        below.
    *)
    | Dwn of tree
    (* Going up a `P` for which we have the left part. Current instructions are the right part.
        Done, concatenate and add `PAIR` at the end. *)
    | Upp of Mic.t list

    (* Sequence of instructions corresponding to `UNPAIR`. *)
    let unpair_inss : Mic.t list = [
        Mic.Dup |> Mic.mk_leaf ;
        Mic.Car |> Mic.mk_leaf ;
        Mic.Dip (Mic.Cdr |> Mic.mk_leaf) |> Mic.mk ;
    ]

    (* Turns a tree for an unpair macro into a list of instructions. *)
    let macro_unpair_tree_to_list (tree : tree) : Mic.t list =
        (* Go down the tree and decide what to do. *)
        let rec go_down (stack : un_stack_frame list) (tree : tree) : Mic.t list =
            match tree with
            (* Simple pair deconstructor. *)
            | Pair (LeafA, LeafI) -> go_up stack unpair_inss
            (* Left part is fine, go down the left part. *)
            | Pair (LeafA, right) -> go_down (UppDipPref :: stack) right
            (* Right part is fine, go down the right part. *)
            | Pair (left, LeafI) -> go_down (UppPref :: stack) left
            (* Go down left first, then right. *)
            | Pair (left, right) -> go_down (
                (Dwn right) :: stack
            ) left
            (* Everything else should be illegal. *)
            | _ -> bail_pair ()
        (* Go up the stack, building the instructions as we go. *)
        and go_up (stack : un_stack_frame list) (lst : Mic.t list) : Mic.t list =
            match stack with
            (* Going up an `A`: `DIP` instructions and add `UNPAIR` at the beginning. *)
            | UppDipPref :: stack ->
                let dipped = Mic.Dip (Mic.mk_seq lst) |> Mic.mk in
                unpair_inss @ [ dipped ] |> go_up stack
            (* Going up an `I`: prefix with `UNPAIR`. *)
            | UppPref :: stack ->
                unpair_inss @ lst |> go_up stack
            (* Need to go down `tree`, memorize `lst` in the stack for later. *)
            | (Dwn tree) :: stack ->
                go_down ((Upp lst) :: stack) tree
            (* We have the left (`lft`) and right (`lst`) instructions, just need to build the
                pair.
            *)
            | (Upp lft) :: stack ->
                go_up stack (unpair_inss @ lft @ lst)
            (* We drained the stack, done. *)
            | [] -> lst
        in
        go_down [] tree

    (* Helper for `SET_C[AD]+R` and `MAP_C[AD]+R`.
    
        Takes the sequence of instruction leaves (`A` or `D`) correspond to. *)
    let macro_cadr_ins
        (leaf_A : Mic.t list)
        (leaf_D : Mic.t list)
        (ops : Mic.Macro.unpair_op list)
        : Mic.t list
    =
        (* Go down the list of operators. This function only calls `go_up` when it ran out of
            operators.
        *)
        let rec go_down (stack : (Mic.t list * Mic.t * Mic.t list) list) (ops : Mic.Macro.unpair_op list) : Mic.t list =
            match ops with
            | [A] -> go_up stack leaf_A
            | [D] -> go_up stack leaf_D
            | A :: ops ->
                go_down
                    (
                        (
                            [ Mic.mk_leaf Mic.Dup ],
                            Mic.mk_leaf Mic.Car,
                            [
                                Mic.mk_leaf Mic.Cdr ;
                                Mic.mk_leaf Mic.Swap ;
                                Mic.mk_leaf Mic.Pair
                            ]
                        ) :: stack
                    )
                    ops
            | D :: ops ->
                go_down
                    (
                        (
                            [ Mic.mk_leaf Mic.Dup ],
                            Mic.mk_leaf Mic.Cdr,
                            [
                                Mic.mk_leaf Mic.Car ;
                                Mic.mk_leaf Mic.Pair
                            ]
                        ) :: stack
                    )
                    ops
            | [] -> Exc.unreachable ()

        (* Goes up the stack constructing the instruction list. *)
        and go_up
            (stack : (Mic.t list * Mic.t * Mic.t list) list)
            (lst : Mic.t list)
            : Mic.t list
        =
            match stack with
            | (pref, ins, suff) :: stack ->
                let inner =
                    Mic.Dip (ins :: lst |> Mic.mk_seq) |> Mic.mk
                in
                inner :: suff |> List.rev_append pref |> go_up stack
            | [] -> lst
        in
        go_down [] ops
end

let macro_pair (ops : Mic.Macro.pair_op list) : Mic.t list =
    PairHelp.macro_pair_to_tree ops |> PairHelp.macro_pair_tree_to_list

let macro_unpair (ops : Mic.Macro.pair_op list) : Mic.t list =
    PairHelp.macro_pair_to_tree ops |> PairHelp.macro_unpair_tree_to_list

let macro_cadr (ops : Mic.Macro.unpair_op list) : Mic.t list =
    let rec loop (acc : Mic.t list) (ops : Mic.Macro.unpair_op list) : Mic.t list =
        match ops with
        | A :: ops -> loop ((Mic.mk_leaf Mic.Car) :: acc) ops
        | D :: ops -> loop ((Mic.mk_leaf Mic.Cdr) :: acc) ops
        | [] -> List.rev acc
    in
    loop [] ops

let macro_set_cadr (ops : Mic.Macro.unpair_op list) : Mic.t list =
    PairHelp.macro_cadr_ins
        (* Instructions for `SET_CAR`. *)
        [ Mic.mk_leaf Cdr ; Mic.mk_leaf Swap ; Mic.mk_leaf Pair ]
        (* Instructions for `SET_CDR`. *)
        [ Mic.mk_leaf Car ; Mic.mk_leaf Pair ]
        ops

let macro_map_cadr (ops : Mic.Macro.unpair_op list) (ins : Mic.t) : Mic.t list =
    PairHelp.macro_cadr_ins
        (* Instructions for `MAP_CAR`. *)
        [
            Mic.mk_leaf Dup ;
            Mic.mk_leaf Cdr ;
            Mic.Dip (
                [ Mic.mk_leaf Car ; ins ] |> Mic.mk_seq
            ) |> Mic.mk ;
            Mic.mk_leaf Swap ;
            Mic.mk_leaf Pair
        ]
        (* Instructions for `MAP_CDR`. *)
        [
            Mic.mk_leaf Dup ;
            Mic.mk_leaf Cdr ;
            ins ;
            Mic.mk_leaf Swap ;
            Mic.mk_leaf Car ;
            Mic.mk_leaf Pair
        ]
        ops

let macro_if_some (ins_1 : Mic.t) (ins_2 : Mic.t) : Mic.t list =
    [ Mic.IfNone (ins_2, ins_1) |> Mic.mk ]